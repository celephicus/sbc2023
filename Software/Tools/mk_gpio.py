import csv, sys, re, os
import csv_parser, codegen

# pin    sig       func desc     group     apin  ppin port note
# D1/TXD,RS485_TXD,TXD0,RS485 TX,RS485 Bus,J7/12,31,  PD1, TXD/PCINT17,Bootloader

class GPIOParse(csv_parser.CSVparse):
	def __init__(self):
		csv_parser.CSVparse.__init__(self)
		self.COLUMN_NAMES = 'Pin Sig Func Description Group Apin Ppin Port AltFunc Comment'.split()
	def preprocess(self, row):
		pass
	def validate_col_Pin(self, d):	
		"Turn a pin name like D1/TXD -> '1'"
		d = d.split('/')[0] 				# Get rid of possible alternate pin name after slash.
		if d.startswith('D'): 				# Arduino pins might start with a D
			d = d[1:]
		return d
	def validate_col_Sig(self, sig):	
		'not a valid C identifier'
		if sig:
			sig = codegen.ident_allcaps(sig)
		return sig
	def validate_col_Description(self, desc):	
		if not desc:
			desc = 'None'
		return desc
	def validate_col_Group(self, d):	
		return d if d else 'None'
	def validate_col_Port(self, port):	
		"expected either blank or port like `PA3'"
		if port.startswith('P'):	
			mport = re.match(r'P([A-D])([0-7])$', port)	# Parse out port, bit from like `PA3'.
			assert mport
			self.add_extra('io_port', mport.group(1))
			self.add_extra('io_bit', int(mport.group(2)))
		return port

# Parse...		
INFILE = sys.argv[1]
OUTFILE = os.path.splitext(os.path.basename(INFILE))[0] + '.h'	# Write to current directory
cg = codegen.Codegen(INFILE, OUTFILE)
parser = GPIOParse()
cg.begin(parser.read)

# Postprocess a bit...
pins = {}
direct = []
unused = []
for d in parser.data:
	# print(d)
	if not d['Func']: continue				# Ignore pins with no function.
	if d['Group'] not in pins: pins[d['Group']] = []	# Ready to insert new group...
		
	pins[d['Group']].append((f"GPIO_PIN_{d['Sig']} = {d['Pin']}", d['Description']))		# Insert Arduino pin definition.
	
	if 'direct' in d['Func']:	# Insert a bunch of inline functions to directly access the pin.
		direct.append((d['Sig'], d['Description'], d['io_port'], d['io_bit']))
	if 'unused' in d['Func']:		# List all unused pins
		unused.append(pin)

# Write output file...
cg.add_include_guard()
cg.add_comment(f"This file is autogenerated from `{INFILE}'.")
cg.add_nl()
cg.add_comment('Pin Assignments for Arduino Pro Mini')

cg.add('enum {')
cg.indent()
for group in pins.keys():
	cg.add_comment(group)
	for pindef in pins[group]:
		cg.add(codegen.format_code_with_comments(pindef[0] + ',', pindef[1]))
	cg.add_nl()
cg.dedent()
cg.add('};', eat_nl=True)

if direct:
	cg.add_nl()
	cg.add_comment('Direct access ports.')
	for sig, desc, io_port, io_bit in direct:
		cg.add_nl()
		cg.add_comment(f"{sig}: {desc}")
		sigCC = codegen.ident_camel(sig, leading=True)
		cg.add(codegen.mk_short_function(f"gpio{sigCC}SetModeOutput", f"DDR{io_port} |= _BV({io_bit};", leader='static inline'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}SetModeInput", f"DDR{io_port} &= ~_BV({io_bit};", leader='static inline'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}SetMode", f"if (fout) DDR{io_port} |= _BV({io_bit}); else DDR{io_port} &= ~_BV({io_bit});", 
		  leader='static inline', args='bool fout'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}Read", f"return PIN{io_port} | _BV({io_bit});", ret='bool', leader='static inline'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}Toggle", f"PORT{io_port} ^= _BV({io_bit};", leader='static inline'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}Set", f"PORT{io_port} |= _BV({io_bit};", leader='static inline'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}Clear", f"PORT{io_port} &= ~_BV({io_bit};", leader='static inline'))
		cg.add(codegen.mk_short_function(f"gpio{sigCC}Write", f"if (b) PORT{io_port} |= _BV({io_bit}); else PORT{io_port} &= ~_BV({io_bit});", 
		  leader='static inline', args='bool b'))

if unused:
	cg.add(f"#define GPIO_UNUSED_PINS {', '.join(unused)}")
		
cg.end()
sys.exit()

	
