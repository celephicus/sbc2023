import csv, sys, re, os

pins = {}
direct = []
unused = []

infile = sys.argv[1]
outfile = os.path.splitext(os.path.basename(infile))[0] + '.h'	# Write to current directory

with open(infile, 'rt') as csvfile:
	reader = csv.reader(csvfile)
	for row in reader:
		# pin    sig       func desc     group     apin  ppin port
		# D1/TXD,RS485_TXD,TXD0,RS485 TX,RS485 Bus,J7/12,31,  PD1, TXD/PCINT17,Bootloader
		try:
			pin = row[0].split('/')[0] # Get rid of possible alternate pin name after slash.
			sig, func, desc, group, apin, ppin, port = row[1:8]
		except IndexError:
			continue
		if not func or row[0].startswith('#'): # Ignore blanks & comments 
			continue
		if not group:	# Make group if not set.
			group = 'None'
		if pin.startswith('D'): # Arduino pins might start with a D
			pin = pin[1:]
		comment = '// ' + desc if desc else ''	# Format description as comment.
		sigCC = ''.join([s.title() for s in sig.split('_')]) # Make CamelCase version of signal name so TX_EN -> TxEn

		mport = re.match(r'P([A-D])([0-7])$', port)	# Parse out port, bit from like `PA3'.
		if mport:			# If no port def, ignore, will give error if tagged as `direct'. 
			io_port, io_bit = mport.groups()
		else:
			io_port, io_bit = None, None
			
		if group not in pins: # Ready to insert new group...
			pins[group] = []
			
		text = f'GPIO_PIN_{sig.upper()} = {pin},'	# Insert Arduino pin definition.
		pins[group].append(f'{text:48}{comment}') # For example line above this is `GPIO_PIN_RS485_TXD = 1                   /* RS485 TX */'.
		
		if 'direct' in func:	# Insert a bunch of inline functions to directly access the pin.
			direct.append(f'''\
{comment}			
static inline void gpio{sigCC}SetModeOutput() {{ DDR{io_port} |= _BV({io_bit}); }}													
static inline void gpio{sigCC}SetModeInput() {{ DDR{io_port} &= ~_BV({io_bit}); }}													
static inline void gpio{sigCC}SetMode(bool fout) {{ if (fout) DDR{io_port} |= _BV({io_bit}); else DDR{io_port} &= ~_BV({io_bit}); }}
static inline bool gpio{sigCC}Read() {{ return !!(PIN{io_port} | _BV({io_bit})); }}
static inline void gpio{sigCC}Toggle() {{ PORT{io_port} ^= _BV({io_bit}); }}												
static inline void gpio{sigCC}Set() {{ PORT{io_port} |= _BV({io_bit}); }}															
static inline void gpio{sigCC}Clear() {{ PORT{io_port} &= ~_BV({io_bit}); }}															
static inline void gpio{sigCC}Write(bool b) {{ if (b) PORT{io_port} |= _BV({io_bit}); else PORT{io_port} &= ~_BV({io_bit}); }}
''')		
		
		if 'unused' in func:		# List all unused pins
			unused.append(pin)

try:
	existing = open(outfile, 'rt').read()
except FileNotFoundError:
	existing = None
	
text = []
text.append(f'''\
#ifndef GPIO_LOCAL_H__
#define GPIO_LOCAL_H__

// This file is autogenerated from `{infile}'.

// Pin Assignments for Arduino Pro Mini
enum {{   \
''')
        
for group in pins.keys():
	text.append(f'\t/* {group} */')
	text.append(''.join([f'\t{pdef}\n' for pdef in pins[group]]))

text.append('};\n')

if direct:
	text.append('// Direct access ports.	')
	text.append('\n'.join(direct))
	text.append('\n')

if unused:
	text.append(f"#define GPIO_UNUSED_PINS {', '.join(unused)}\n")
	
text.append('#endif		// GPIO_LOCAL_H__')	

text = '\n'.join(text)
if text != existing:
	print("Updated file %s." % outfile, file=sys.stderr)
	open(outfile, 'wt').write(text)
else:
	print("Skipped file %s as unchanged." % outfile, file=sys.stderr)

